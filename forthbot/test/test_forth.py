import signal
import subprocess
import time
import os
import sys

from twisted.trial.unittest import TestCase, SkipTest
from twisted.python.filepath import FilePath

from forthbot import SlaveNotRunning, Lock, Monitor, parsePS

VSZ = 16276
RSS = 13492
PMEM = 5.4
PS_OUTPUT = "VSZ   RSS %%MEM\n%d %d  %f\n" % (VSZ, RSS, PMEM)
EMPTY_PS_OUTPUT = "VSZ   RSS %MEM\n"

class FakeLock(object):
    def __init__(self, locked):
        self._locked = locked

    def lock(self):
        if self._locked:
            return False
        self._locked = True
        return True


class MemoryTests(TestCase):
    """
    Tests for memory-forthboting related functionality.
    """
    def test_parsePS(self):
        """
        parsePS accepts a string generated by `ps -o vsz,rss,%mem -p
        <pid>` and returns a three-tuple of vsize, resident set size,
        and percent of memory in use.
        """
        self.assertEquals(parsePS(PS_OUTPUT), (VSZ, RSS, PMEM))


    def test_noProcess(self):
        self.assertEquals(parsePS(EMPTY_PS_OUTPUT), None)


class MonitorTests(TestCase):
    """
    Tests for Monitor.
    """
    def setUp(self):
        self.calls = []
        self.slavepath = FilePath(__file__).sibling('testSlave')
        self.m = Monitor(FakeLock(False))

    def test_run(self):
        """
        Monitor.run accepts a path to the slave to forthbot and calls
        checkMemoryUsage with that path.
        """
        checks = []
        checkupgrades = []
        m = Monitor(FakeLock(False))
        m.checkMemoryUsage = checks.append
        m.checkUpgrades = checkupgrades.append
        m.run("/foo/bar")
        self.assertEquals(checks, ["/foo/bar"])
        self.assertEquals(checkupgrades, ['/foo/bar'])


    def test_noConcurrentRuns(self):
        """
        If Monitor cannot lock the lock passed to it, it doesn't do
        any checking.
        """
        checks = []
        checkupgrades = []
        m = Monitor(FakeLock(True))
        m.checkMemoryUsage = checks.append
        m.checkUpgrades = checkupgrades.append

        # Concurrent run should be an error exit status.
        exc = self.assertRaises(SystemExit, m.run, "/foo/bar")
        self.assertEquals(exc.args, (1,))

        # And no checks performed, please.
        self.assertEquals(checks, [])
        self.assertEquals(checkupgrades, [])


    def test_runWhenSlaveNotRunning(self):
        """
        """
        def fakeCheck(path):
            raise SlaveNotRunning()

        starts = []
        m = Monitor(FakeLock(False))
        m.checkUpgrades = lambda a: None
        m.checkMemoryUsage = fakeCheck
        m.start = starts.append

        m.run("/foo/bar")
        self.assertEquals(starts, ["/foo/bar"])


    def test_checkUpgrades(self):
        """
        Monitor.checkUpgrades accepts a path to a slave to check, and calls 
        doUpgrade if slavepath/forthbot/commands/upgrademe exists
        """
        slavepath = FilePath(self.mktemp())
        forthbot_commands = slavepath.child('forthbot').child('commands')
        forthbot_commands.makedirs()
        upgrademe = forthbot_commands.child('upgrademe')
        upgrademe.setContent('1234')
        checkupgrades = []
        m = Monitor(FakeLock(False))
        upgrades = []
        m.doUpgrade = upgrades.append
        m.checkUpgrades(slavepath.path)
        self.assertEquals(upgrades, [upgrademe.path])

    def test_mkforthbotdirs(self):
        """
        Monitor.checkUpgrades creates the directories log, work,
        commands in slavepath/forthbot if they don't exist already
        """
        slavepath = FilePath(self.mktemp())
        forthbot = slavepath.child('forthbot')
        log = forthbot.child('log')
        commands = forthbot.child('commands')
        work = forthbot.child('work')
        m = Monitor(FakeLock(False))
        m.checkUpgrades(slavepath.path)
        self.assertTrue(forthbot.exists())
        self.assertTrue(log.exists())
        self.assertTrue(commands.exists())
        self.assertTrue(work.exists())

    def _setupUpgrade(self):
        slavepath = FilePath(__file__).sibling('testSlave')
        forthbot_commands = slavepath.child('forthbot').child('commands')
        forthbot_log = slavepath.child('forthbot').child('log')
        upgradefailed = forthbot_log.child('upgradefailed')
        forthbot_log.child('foobar').setContent('foobar')
        upgrademe = forthbot_commands.child('upgrademe')
        return slavepath, forthbot_commands, forthbot_log, upgradefailed, upgrademe


    def _fakecall(self, args, env={}, retval=(0,'success')):
        self.calls.append((args, env))
        return retval


    def test_doUpgrade(self):
        """
        Monitor.doUpgrade accepts a path to the upgrademe file it
        deletes this file and all files in slavepath/forthbot/log/*
        forthbot/work/* It calls install_pkg which returns True or
        False Finishing in failure writes a reason to
        slavepath/forthbot/log/upgradefailed Success will stop hitch so
        the new code can start later.
        """
        slavepath, forthbot_commands, forthbot_log, upgradefailed, upgrademe = self._setupUpgrade()
        upgrademe.setContent('1234')
        m = Monitor(FakeLock(False))
        m._call = self._fakecall
        m._hitch_call = lambda a, b: self.calls.append('hitchstop')
        m.doUpgrade(upgrademe.path)
        self.assertFalse(forthbot_commands.child('upgrademe').exists())
        self.assertEquals(forthbot_log.children(), [])
        self.assertEquals(self.calls[-1], 'hitchstop')


    def test_doUpgradeFail(self):
        """
        Monitor.doUpgrade doesn't stop hitch when _pkg_add fails
        """
        slavepath, forthbot_commands, forthbot_log, upgradefailed, upgrademe = self._setupUpgrade()
        upgrademe.setContent('1234')
        m = Monitor(FakeLock(False))
        m._call = lambda args, env={}: self._fakecall(args, env, retval=(1, 'failure'))
        m._hitch_call = lambda a, b: self.calls.append('hitchstop')
        m.doUpgrade(upgrademe.path)
        self.assertFalse(forthbot_commands.child('upgrademe').exists())
        self.assertEquals(forthbot_log.children(), [upgradefailed])
        self.assertTrue('hitchstop' not in self.calls)



    def test_get_pkg_info(self):
        """
        Monitor.pkg_info calls pkg_info in the shell and returns a
        list of the hitch packages
        """
        pkginfo = '''\
troops-222-3.2.1.2.3 troops
hitch-0.90-190-gbe42164 hitch
hitch-0.90-192-gc877767 hitch
floor-292-123123 floor
gage-9-0-2-1-3-maaa gage
'''
        good = ['hitch-0.90-190-gbe42164', 'hitch-0.90-192-gc877767']
        m = Monitor(FakeLock(False))
        calls = []
        def fakeCall(args, env={}):
            calls.append((args,env))
            return 0, pkginfo
        m._call = fakeCall
        self.assertEquals(m.pkg_info(), good)
        self.assertEquals(calls, [(['pkg_info'], {})])


    def test_pkg_delete(self):
        """
        Monitor.delete_pkg accepts a slavepath and call pkg_info to
        get the installed hitch package(s) and then calls pkg_delete
        on each.
        """
        pkginfo = ['hitch-0.90-190-gbe42164', 'hitch-0.90-192-gc877767']
        m = Monitor(FakeLock(False))
        calls = []
        def fakeCall(args, kw={}):
            calls.append((args, kw))
        m._call = fakeCall
        m.pkg_info = lambda : pkginfo
        m.pkg_delete()
        self.assertEquals(calls, [(['pkg_delete', 'hitch-0.90-190-gbe42164'], {}), (['pkg_delete', 'hitch-0.90-192-gc877767'], {})])


    def test_fetch_cmd(self):
        """
        Fetch calls _call with the right wget command
        """
        m = self.m

        calls = []
        m._call = lambda *a, **kw: calls.append((a, kw))
        


    def test_install_pkg_fetch_fail(self):
        """
        if fetch_pkg fails then don't call pkg_delete and return a failure
        """
        m = Monitor(FakeLock(False))
        calls = []
        def fail(*a, **kw):
            calls.append('fail')
            raise Exception('wget failed to download new hitch')
        def _pkg_add(*a, **kw):
            calls.append('_pkg_add')
            return 0, 'foobar'
        m.fetch_pkg = fail
        m.pkg_delete = lambda : calls.append('pkg_delete')
        m._pkg_add = _pkg_add
        retval = m.install_pkg(self.slavepath.path)
        self.assertEquals(calls, ['fail'])
        self.assertEquals(retval, False)
        self.assertEquals(m.install_pkg_failure_text, 'wget failed to download new hitch')


    def test_install_pkg(self):
        """
        Monitor.install_pkg accepts a slavepath and pkg_delete
        and then pkg_add with the right environment and arguments
        """
        slavepath = FilePath(__file__).sibling('testSlave')
        work = slavepath.child('forthbot').child('work')
        keys = slavepath.child('keys')
        pkg_add = ['/usr/sbin/pkg_add', '-r', 'hitch']
        wget = "/usr/local/bin/wget --certificate=%(cert)s " \
               "--private-key=%(priv)s " \
               "--ca-certificate=%(ca)s " \
               "-O -" % {
                      'priv': keys.child('client1.key').path,
                      'cert': keys.child('client1.crt').path,
                      'ca': keys.child('ca.crt').path,
                      }
        pkgroot = "https://%(host)s:%(port)s" % {'host':'204.238.82.6', 'port':10233}
        correctenv = {'PACKAGEROOT': pkgroot, 'FETCH_CMD': wget}
        justFail = False
        calls = []
        failure_reason = 'bad news'
        def fakeCall(args, env={}):
            calls.append((args, env))
            if justFail:
                return (1, failure_reason)
            return (0, 'worked')
        m = Monitor(FakeLock(False))
        m.pkg_delete = lambda : calls.append('pkg_delete')
        m._call = fakeCall
        retval = m.install_pkg(slavepath.path)
        print correctenv
        print pkg_add
        self.assertEquals(calls, ['pkg_delete', (pkg_add, correctenv)])
        justFail = True
        retval = m.install_pkg(slavepath.path)
        self.assertFalse(retval)
        self.assertEquals(m.install_pkg_failure_text, failure_reason)



    def test_run_order(self):
        """
        Monitor.run checks for lock, upgrade and then memory usage
        """
        calls = []
        m = Monitor(FakeLock(False))
        def fakelock():
            calls.append('lock')
            return True
        m._lock.lock = fakelock
        m.checkUpgrades = lambda a: calls.append('checkUpgrades')
        m.checkMemoryUsage = lambda a: calls.append('checkMemoryUsage')
        m.run(None)
        self.assertEquals(calls, ['lock', 'checkUpgrades', 'checkMemoryUsage'])


    def test_checkMemoryUsage(self):
        """
        Monitor.checkMemoryUsage accepts a path to a slave to check,
        loads the PID from the pidfile in that directory, and calls
        Monitor.getMemoryUsage with that PID.
        """
        slavepath = FilePath(self.mktemp())
        slavepath.makedirs()
        slavepath.child('twistd.pid').setContent('1234')
        checks = []
        m = Monitor(FakeLock(False))
        def fakePS(pid):
            checks.append(pid)
            return PS_OUTPUT
        m.ps = fakePS

        def fakeLimit(vsz, rss, pmem):
            checks.append((vsz, rss, pmem))
            return False
        m.limitExceeded = fakeLimit

        def fakeKill(pid):
            checks.append(pid)
        m.fakeKill = fakeKill

        m.run(slavepath.path)
        self.assertEquals(checks, [1234, (VSZ, RSS, PMEM)])


    def test_checkMemoryUsageExceeded(self):
        """
        Monitor.run restarts the process if it finds the memory limit
        has been exceeded after first checking for updates
        """
        slavepath = FilePath(self.mktemp())
        slavepath.makedirs()
        slavepath.child('twistd.pid').setContent('1234')

        m = Monitor(FakeLock(False))
        m.ps = lambda pid: PS_OUTPUT
        m.limitExceeded = lambda vsz, rss, pmem: True
        restarts = []
        m.restart = restarts.append
        m.run(slavepath.path)
        self.assertEquals(restarts, [slavepath.path])


    def test_limitExceeded(self):
        """
        Monitor.limitExceeded returns True if vsz is greater than
        20MB.  It returns False otherwise.
        """
        m = Monitor(FakeLock(False))
        self.assertTrue(m.limitExceeded(20 * 1024 + 1, None, None))
        self.assertFalse(m.limitExceeded(20 * 1024, None, None))


    def test_missingPIDFile(self):
        """
        If no slave is running in the specified directory,
        Monitor.checkMemoryUsage raises SlaveNotRunning.
        """
        slavepath = FilePath(self.mktemp())
        slavepath.makedirs()

        m = Monitor(FakeLock(False))
        self.assertRaises(
            SlaveNotRunning, m.checkMemoryUsage, slavepath.path)


    def test_emptyPIDFile(self):
        """
        If the pid file is empty the slave is not running
        """
        slavepath = FilePath(self.mktemp())
        slavepath.makedirs()
        slavepath.child("twistd.pid").setContent('')

        m = Monitor(FakeLock(False))
        self.assertRaises(
            SlaveNotRunning, m.checkMemoryUsage, slavepath.path)



    def test_pidNotRunning(self):
        """
        """
        slavepath = FilePath(self.mktemp())
        slavepath.makedirs()
        slavepath.child("twistd.pid").setContent("12345")
        m = Monitor(FakeLock(False))
        m.ps = lambda pid: EMPTY_PS_OUTPUT
        self.assertRaises(
            SlaveNotRunning, m.checkMemoryUsage, slavepath.path)




class AXMonitorFunctionalTests(TestCase):
    """
    Test the Monitor against a real slave process.
    """
    def setUp(self):
        """
        Reset the SIGCHLD handler to the default so that the Monitor
        can run child processes using the subprocess module.
        """
        self.slavepath = FilePath(__file__).sibling('testSlave')
        self.addCleanup(self._stopSlave)

        original = signal.signal(signal.SIGCHLD, signal.SIG_DFL)
        self.addCleanup(signal.signal, signal.SIGCHLD, original)


    def _stopSlave(self):
        # Wait a little bit so that the cleanup "hitch stop" doesn't
        # happen before the slave is ready to deal with it.  It'd be
        # nice to do this without a sleep.  See Twisted #823.
        time.sleep(2)

        subprocess.call(['hitch', 'stop', '-q', self.slavepath.path])


    def test_memoryLimitExceeded(self):
        """
        A slave which has exceeded the allowed memory usage is restarted.
        """
        slavepath = self.slavepath
        proc = subprocess.Popen(['hitch', 'start', '-q', slavepath.path])
        # XX Fix this - waiting for the slave to really start.
        time.sleep(2)

        # Learn the PID of this instance of the slave.
        pid = slavepath.child('twistd.pid').getContent()

        m = Monitor(FakeLock(False))
        m._memoryLimit = 1
        m.run(slavepath.path)

        # Make sure the PID has changed.
        newpid = slavepath.child('twistd.pid').getContent()
        self.assertNotEquals(pid, newpid)

        # Make sure the new process is actually running as well.  This
        # will raise ESRCH if it is not.
        os.kill(int(newpid), 0)


    def test_slaveNotRunning(self):
        m = Monitor(FakeLock(False))
        m.run(self.slavepath.path)
        self.assertTrue(self.slavepath.child('twistd.pid').exists())
        pid = self.slavepath.child('twistd.pid').getContent()
        os.kill(int(pid), 0)


    def test_forthbotAfterRestart(self):
        """
        The forthbot lock is released after L{Monitor.run} returns.
        """
        proxybox = FilePath(__file__).parent().parent().parent()
        hmon = proxybox.child("bin").child("hmon").path
        firstStatus = subprocess.call([hmon, self.slavepath.path])
        self.assertFalse(firstStatus)
        secondStatus = subprocess.call([hmon, self.slavepath.path])
        self.assertFalse(secondStatus)



class LockTests(TestCase):
    """
    Tests for Lock.
    """
    def test_lockUnlocked(self):
        """
        Lock.lock returns True if it acquires the lock.
        """
        f = self.mktemp()
        l = Lock(f)
        self.assertTrue(l.lock())


    def test_lockLocked(self):
        """
        Lock.lock returns False if it fails to acquire the lock
        immediately.
        """
        f = self.mktemp()
        first = Lock(f)
        first.lock()
        second = Lock(f)
        self.assertFalse(second.lock())
